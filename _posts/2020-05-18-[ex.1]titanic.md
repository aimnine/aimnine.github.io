---
title: "[예제로 공부하는 단단한 머신러닝] example 01. 타이타닉 생존자 예측"
date: 2020-05-18 00:00:00 -0400
categories: MachineLearning
---

첫 예제는 타이타닉 생존자 예측 문제이다.

워낙 유명한 문제이기도 하고, 케글(kaggle) 등에 다양한 해법들이 이미 존재하고 있다.

튜토리얼도 많이 존재하기 때문에, 첫 번째 예제로 적합하다고 생각했고, 실제로 tensorflow의 공식 튜토리얼을 참고했다.

- Tensorflow tutorial : https://www.tensorflow.org/tutorials/load_data/csv?hl=ko

예제를 진행하기 위해서는 파이썬 개발환경(Tensorflow 등 기타 파이썬 패키지가 포함된)이 필요한데, 가장 접근이 용이한 google colab을 사용하는 것을 추천한다.

# 1. Setup
- 머신러닝을 수행하기 위해서, 필요한 파이썬 라이브러리를 불러오고,
<pre>
<code class="python">
import functools

import numpy as np
import tensorflow as tf
</code>
</pre>
- 데이터를 가져오는 과정이다.
<pre>
<code class="python">
TRAIN_DATA_URL = "https://storage.googleapis.com/tf-datasets/titanic/train.csv"
TEST_DATA_URL = "https://storage.googleapis.com/tf-datasets/titanic/eval.csv"

train_file_path = tf.keras.utils.get_file("train.csv", TRAIN_DATA_URL)
test_file_path = tf.keras.utils.get_file("eval.csv", TEST_DATA_URL)
</code>
</pre>
- 예제(혹은 튜토리얼) 문제들은 비교적 예쁘게? 데이터가 정리되어있지만, 실제 머신러닝이 적용되어야 할 문제들에서는 이와 같은 작업이 선행되어 있지않다.
- 머신러닝에 관련된 발표를 듣다보면, 데이터를 모으고, 처리하는 과정(예제의 경우, .csv파일이 그 결과)이 전체 머신러닝 프로세스의 70%(혹은 그 이상)이라고 한다.
- 또, 많이 이야기 하는 것이 **Garbage In, Garbage Out**으로 머신러닝으로 문제를 해결하기 위해 좋은? 데이터를 사용하는 것도 중요하다고 한다(Garbage가 아닌 데이터가 무엇일지 생각해보자)

# 2. Load data
- 앞선 과정에서, 문제에 적용하기 위해서 데이터를 가져왔다.
- 가져온 데이터 중 학습 데이터를 간략하게 살펴본다(쉘스크립트)
<pre>
<code class="shell">
head {train_file_path}
</code>
</pre>
- 대략 이런 데이터들을 볼 수 있다.
<pre>
<code>
survived,sex,age,n_siblings_spouses,parch,fare,class,deck,embark_town,alone
0,male,22.0,1,0,7.25,Third,unknown,Southampton,n
1,female,38.0,1,0,71.2833,First,C,Cherbourg,n
1,female,26.0,0,0,7.925,Third,unknown,Southampton,y
1,female,35.0,1,0,53.1,First,C,Southampton,n
0,male,28.0,0,0,8.4583,Third,unknown,Queenstown,y
</code>
</pre>
- 각 행은 하나의 데이터를 의미하고, 각 데이터 속에는 다양한 **속성**들이 존재한다.
- 가장 첫 번째 열은 생존유무를 나타내는 것으로, 타이타닉 생존자 예측 문제에서 이는 각 데이터의 정답, 즉 **라벨**이 된다.
<pre>
<code class="python">
LABEL_COLUMN = 'survived'
LABELS = [0, 1]
</code>
</pre>
- 라벨 값을 보면, 0과 1로 구분된다. 이렇게 둘 중 하나로 분류하는 문제를 **이진 분류**(binary classification)이라고 한다(이 문제에서 0은 사망, 1은 생존을 의미하는 듯 하다.)
- 그 외의 다른 열들(성별, 나이, 운임료 등)은 머신러닝에서 활용할 수 있는 **속성 값**들이 되고, 이 속성(전체 혹은 일부)들을 묶어서 **속성 공간**에 위치시키거나 **속성 벡터**로 만들 수 있다.

- 앞서 가져온(다운받은) 데이터를 파이썬에서 처리하기 위해 읽어오는 함수를 사용한다(예전의 예제들은 pandas라는 패키지를 이용해서 csv파일을 읽어오고 하는 과정을 했던 것 같은데, 이 튜토리얼에서는 tensorflow의 make_csv_dataset이라는 함수를 사용한다.)
<pre>
<code class="python">
def get_dataset(file_path, **kwargs):
  dataset = tf.data.experimental.make_csv_dataset(
      file_path,
      batch_size=5, # Artificially small to make examples easier to show.
      label_name=LABEL_COLUMN,
      na_value="?",
      num_epochs=1,
      ignore_errors=True, 
      **kwargs)
  return dataset

raw_train_data = get_dataset(train_file_path)
raw_test_data = get_dataset(test_file_path)
</code>
</pre>
- 살펴보면, 함수에 csv파일의 위치와 배치(한번에 처리하는 단위?)크기, 라벨이름, na value 등 다양한 매개변수가 입력되는 것을 확인할 수 있다.
- 친절하게 배치 단위로 읽어보는 함수도 있다.
<pre>
<code class="python">
def show_batch(dataset):
  for batch, label in dataset.take(1):
    for key, value in batch.items():
      print("{:20s}: {}".format(key,value.numpy()))

show_batch(raw_train_data)
</code>
</pre>
- 결과
<pre>
<code>
sex                 : [b'female' b'male' b'female' b'male' b'male']
age                 : [19. 36. 25. 26. 19.]
n_siblings_spouses  : [1 0 1 0 0]
parch               : [0 0 1 0 0]
fare                : [ 7.854 26.388 30.    18.788  6.75 ]
class               : [b'Third' b'First' b'Second' b'Third' b'Third']
deck                : [b'unknown' b'E' b'unknown' b'unknown' b'unknown']
embark_town         : [b'Southampton' b'Southampton' b'Southampton' b'Cherbourg' b'Queenstown']
alone               : [b'n' b'y' b'n' b'y' b'y']
</code>
</pre>
- 또한, 원하는 열(column)만 지정해서 가져올 수 도 있다.
<pre>
<code class="python">
SELECT_COLUMNS = ['survived', 'age', 'n_siblings_spouses', 'class', 'deck', 'alone']

temp_dataset = get_dataset(train_file_path, select_columns=SELECT_COLUMNS)

show_batch(temp_dataset)
</code>
</pre>
- 결과
<pre>
<code >
age                 : [28. 41. 23. 28. 65.]
n_siblings_spouses  : [0 0 0 0 0]
class               : [b'Third' b'Second' b'Second' b'First' b'First']
deck                : [b'unknown' b'unknown' b'unknown' b'unknown' b'B']
alone               : [b'y' b'n' b'y' b'y' b'n']
</code>
</pre>